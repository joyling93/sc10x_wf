log <- file(snakemake@log[[1]], open = "wt")
sink(log)
sink(log, type="message")

library(monocle)
library(SeuratObject)
# library(argparse)

# parser = ArgumentParser()
# parser$add_argument("--rds", help="the rds file")
# parser$add_argument("--clus", help="cluster info of each barcode,generated by seurat",required=TRUE)
# parser$add_argument("--sample", help="sample name",required=TRUE)
# parser$add_argument("--outdir", help='output folder',required=TRUE,default="./")
# parser$add_argument("--ordering_gene",help='Alternative choices for choosing genes that define a cell\'s progress,[differential,dispersion,genelist]',default="dispersion")
# parser$add_argument("--num_paths",help='number of end point',default='NULL')

# args <- parser$parse_args()
# str(args)

rds <- snakemake@input$rds
clus<- snakemake@input$meta
sample<- "integration"
outdir<- dirname(snakemake@output[[1]])
ordering_gene_pattern <- "dispersion"
num_paths <- "NULL"

dir.create(outdir,recursive =T)
#Extract data, phenotype data, and feature data from the SeuratObject

seurat_obj<-readRDS(rds)
clus<-read.table(clus,header=T,sep='\t',row.names=1)
clus$Cluster<-as.factor(clus[,'seurat_clusters'])
pbmc<-subset(seurat_obj,cells=c(rownames(clus)))

#data <- as(as.matrix(pbmc@assays$RNA@counts), 'sparseMatrix')
data=GetAssayData(pbmc,slot = 'counts',assay = 'RNA')
data<-data[,rownames(clus)]

pd <- new('AnnotatedDataFrame', data = clus)

fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))

fd <- new('AnnotatedDataFrame', data = fData)

gbm_cds <- newCellDataSet(data,phenoData = pd,featureData = fd,
	                          lowerDetectionLimit = 0.5,
	                          expressionFamily = negbinomial.size())


### Requirements fot estimateSizeFactors and estimateDispersions
# estimateSizeFactors() and estimateDispersions() will only work, and are only needed, if you are working with a CellDataSet with a negbinomial() or negbinomial.size() expression family.
gbm_cds <- estimateSizeFactors(gbm_cds)
gbm_cds <- estimateDispersions(gbm_cds)

##head(pData(gbm_cds))

#Selecting genes with high dispersion across cells
#We can filter genes based on average expression level, and we can additionally select genes that are unusually variable across cells.

### Trajectory step 1: choose genes that define a cell's progress
if(ordering_gene_pattern=="dispersion"){
	disp_table <- dispersionTable(gbm_cds)
	ordering_genes <- subset(disp_table,
	                  mean_expression >= 0.1 &
	                  dispersion_empirical >= 1 * dispersion_fit) 
##head(ordering_genes$gene)
	gbm_cds <- setOrderingFilter(gbm_cds, ordering_genes$gene_id)
	#pdf(file = paste(outdir,"ordering_genes.pdf",sep='/'), width = 9, height = 5)
	plot_ordering_genes(gbm_cds)
	ggsave(file = paste(outdir,"ordering_genes.png",sep='/'),width = 9, height = 5)
	ggsave(file = paste(outdir,"ordering_genes.pdf",sep='/'),width = 9, height = 5)
	#dev.off()

}else if(ordering_gene_pattern=="differential"){
	##Ordering based on genes that differ between clusters
	gbm_cds <- detectGenes(gbm_cds, min_expr = 0.1)
	fData(gbm_cds)$use_for_ordering <-fData(gbm_cds)$num_cells_expressed > 0.05 * ncol(gbm_cds)
	### differ analysis
	gbm_cds_expressed_genes <- rownames(fData(gbm_cds))

	clustering_DEG_genes <-
		differentialGeneTest(gbm_cds[gbm_cds_expressed_genes,],
		fullModelFormulaStr = '~Cluster',cores = as.integer(snakemake@threads))
	gbm_cds_ordering_genes <-row.names(clustering_DEG_genes)[order(clustering_DEG_genes$qval)][1:1000]
	gbm_cds<-setOrderingFilter(gbm_cds,ordering_genes = gbm_cds_ordering_genes)
}else if(ordering_gene_pattern=="genelist"){	##提过基因list进行分析，如Seurat差异分析等
	genes<-read.table(genelist,header=F)
	gbm_cds<-setOrderingFilter(gbm_cds,ordering_genes = as.character(genes$V1))
}
	
### Trajectory step 2: reduce data dimensionality


### Trajectory step 3: order cells along the trajectory
if(num_paths=='NULL'){
        gbm_cds <- reduceDimension(gbm_cds, max_components = 2,
                                   method = 'DDRTree')
        gbm_cds <- orderCells(gbm_cds)
}else{
        gbm_cds <- reduceDimension(gbm_cds, max_components = 2,
                                   method = 'ICA')
        gbm_cds <- orderCells(gbm_cds,num_paths=as.numeric(num_paths))
}

saveRDS(gbm_cds,file=paste(outdir,'monocle.rds',sep='/'))
write.table(pData(gbm_cds), file = paste(outdir,'cell_Pseudotime.txt',sep='/'), row.names = T, quote = F,sep=',')

###pData(gbm_cds)[,3]<-as.character(pData(gbm_cds)[,3])

#pdf(file =paste(outdir,"cell_trajectory.pdf",sep='/'), width = 9, height = 5)
plot_cell_trajectory(gbm_cds, color_by = "Cluster") +
      ggtitle(sample) + theme(plot.title = element_text(hjust = 0.5),legend.position = "right")
ggsave(file=paste(outdir,"cell_trajectory.pdf",sep='/'),width = 9, height = 5)
ggsave(file=paste(outdir,"cell_trajectory.png",sep='/'),width = 9, height = 5)
#dev.off()

#pdf(file = paste(outdir,"Pseudotime_cell_trajectory.pdf",sep='/'), width = 9, height = 5)
plot_cell_trajectory(gbm_cds, color_by = "Pseudotime") +ggtitle(sample) + theme(plot.title = element_text(hjust = 0.5),legend.position = "top")
ggsave(file=paste(outdir,"Pseudotime_cell_trajectory.pdf",sep='/'),width = 9, height = 5)
ggsave(file=paste(outdir,"Pseudotime_cell_trajectory.png",sep='/'),width = 9, height = 5)
#dev.off()

#pdf(file = paste(outdir,"cell_trajectory_cluster.pdf",sep='/'),width = 12)
plot_cell_trajectory(gbm_cds, color_by = "Cluster") + facet_wrap(~Cluster, nrow = 2, scales = "free")
ggsave(file=paste(outdir,"cell_trajectory_cluster.pdf",sep='/'),width = 12)
ggsave(file=paste(outdir,"cell_trajectory_cluster.png",sep='/'),width = 12)
#dev.off()


#pdf(file =paste(outdir,"cell_trajectory_stat.pdf",sep='/'))
plot_cell_trajectory(gbm_cds, color_by="State") + facet_wrap(~State, nrow = 1)
ggsave(file=paste(outdir,"cell_trajectory_stat.pdf",sep='/'),width = 9, height = 5)
ggsave(file=paste(outdir,"cell_trajectory_stat.png",sep='/'),width = 9, height = 5)
#dev.off()


# ###saveRDS(gbm_cds,file=paste(outdir,'monocle.rds',sep='/'))

# ### Analyzing Branches in Single-Cell Trajectories
# #BEAM takes as input a CellDataSet that's been ordered with orderCells and the name of a branch point in the trajectory. It returns a table of significance scores for each gene. Genes that score significant are said to be branch-dependent in their expression.
# BEAM_res <- BEAM(gbm_cds, branch_point = 1, cores = 30,progenitor_method = "duplicate")  ## branch_point: alternative
# BEAM_res <- BEAM_res[order(BEAM_res$qval),]
# BEAM_res <- BEAM_res[,c("gene_short_name", "pval", "qval")]
# write.table(BEAM_res, file = paste(outdir,'gene_related_to_branch.txt',sep='/'), row.names = F, quote = F,sep=',')
# #save(list =ls(all=TRUE), file=paste(monocle_outdir,"temp.RData",sep="/"))
# # You can visualize changes for all the genes that are significantly branch dependent using a special type of heatmap. Columns are points in pseudotime, rows are genes, and the beginning of pseudotime is in the middle of the heatmap. 
# heatmap_gene<-row.names(BEAM_res)[order(BEAM_res$qval)][1:50]

# pdf(file =paste(outdir, "branch_dependent_gene_heatmap.pdf",sep='/'), width = 9, height = 5)

# plot_genes_branched_heatmap(gbm_cds[heatmap_gene,],
#                                           branch_point = 1,
#                                           num_clusters = 6,
#                                           cores = 2,
#                                           use_gene_short_name = T,
#                                           show_rownames = T)
# ## num_clusters: Number of clusters for the heatmap of branch genes
# dev.off()

# # We can plot a couple of these genes, such as Pdpn and Sftpb (both known markers of fate in this system), using the plot_genes_branched_pseudotime function
# #branched_genes <- row.names(subset(fData(gbm_cds),
# #          gene_short_name %in% c("Ccnd2", "Sftpb", "Pdpn")))
# branched_genes <- row.names(BEAM_res)[order(BEAM_res$qval)][1:3]   #top3
# pdf(file = paste(outdir,"genes_branched_pseudotime.pdf",sep='/'), width = 9, height = 5)

# plot_genes_branched_pseudotime(gbm_cds[branched_genes,],
#                        branch_point = 1,
#                        color_by = "Cluster",
#                        ncol = 1) +ggtitle(sample)+
#                        theme(plot.title = element_text(hjust = 0.5),legend.position = "right")

# dev.off()

# saveRDS(gbm_cds,file=paste(outdir,'monocle.rds',sep='/'))